# CLAUDE.md - Future Instructions

## 1. Generated Files - Do Not Edit Directly

**IMPORTANT: Some files are automatically generated and should NOT be edited manually:**

- `.github/workflows/stages.yml` - Generated by `make stages`
- `DOCKER_DEPENDENCY_ANALYSIS.md` - Generated by `make analysis`
- Individual `Makefile` files in each Docker directory - Generated by `make generate-makefiles`

**When you need to modify these files:**

- Instead of editing directly, modify the `generate_stages.py` script
- Run the appropriate make target to regenerate:
    - `make stages` - Regenerate workflow file
    - `make analysis` - Regenerate dependency analysis
    - `make generate-makefiles` - Regenerate all individual Makefiles
- Look for header comments like "Generated by generate_stages.py, do not edit by hand" to identify generated files

## 2. Use `pak::pak()` for R Package Installation

- **Always use** `pak::pak(c("package1", "package2"))` instead of `install.packages()`
- Benefits: faster parallel downloads, better dependency resolution, more robust error handling
- Example: `RUN R -q -e 'pak::pak(c("devtools", "usethis", "languageserver"))'`

## 3. Preserve Cache Invalidation Files

- **Do not remove** `COPY date.txt /date.txt` lines from Dockerfiles
- These files are used for build cache invalidation to ensure fresh package installations
- When date.txt changes, it forces rebuilds of the entire pipeline

## 4. Use Concatenated Commands for Layer Optimization

- **Always concatenate** related RUN commands using `&&` to minimize Docker layers
- **Always include cleanup** at the end. Ubuntu example: `rm -rf /var/lib/apt/lists/* && rm -rf /tmp/* && rm -rf /var/tmp/*`
- Group logical operations together: system package installation, R package installation, configuration
- RUN followed by backslash, && \ at the end of each line, true in the last line
- Example:

  ```dockerfile
  # Install system dependencies and R packages, then clean up
  RUN apt-get update && apt-get install -y package1 package2 && \
      R -q -e 'pak::pak(c("pkg1", "pkg2"))' && \
      rm -rf /var/lib/apt/lists/* && \
      rm -rf /tmp/* && \
      rm -rf /var/tmp/* && \
      true
  ```

## 5. Docker Image Architecture Best Practices

- Maintain logical build pipeline staging based on dependencies
- Use minimal image layers and appropriate base images
- Separate concerns: base images, R variants, specialized tools
- Document image purposes and dependencies clearly

## 6. Multi-Architecture Builds

- By default, all images are built for both **amd64** and **arm64** architectures
- The workflow automatically provides the `TARGETARCH` build argument
- **To use architecture information in your Dockerfile:**

  ```dockerfile
  # Declare the build arguments
  ARG TARGETARCH

  # Use them in RUN commands
  RUN echo "Building for ${TARGETARCH}"

  # For architecture-specific logic
  RUN if [ "$TARGETARCH" = "arm64" ]; then \
        echo "ARM64-specific setup"; \
      fi
  ```

- See `.github/ARCHITECTURE_SUPPORT.md` for comprehensive documentation on architecture support and restrictions

### 6.1 Understanding Multi-Platform Image Tags

**IMPORTANT**: We build **multi-platform images with manifests**. Here's what that means:

- During build, architecture-specific images are created with tags like `latest-amd64` and `latest-arm64`
- A **manifest** is then created that combines both architectures under the `latest` tag
- When using the images, prefer `image:latest`** - Docker will automatically pull the correct architecture

### 6.2 Restricting Architecture Support

Sometimes an image cannot be built for all architectures due to dependencies or platform limitations.

- **To restrict an image to specific architectures**, add a comment at the top of the Dockerfile:

  ```dockerfile
  # arch: amd64
  ```

  or for multiple architectures:

  ```dockerfile
  # arch: amd64, arm64
  ```

- This comment must appear within the first 10 lines of the Dockerfile
- The `generate_stages.py` script will automatically detect this and:
    - Generate the appropriate workflow configuration to build only specified architectures
    - Generate Makefiles with only the relevant architecture-specific targets
    - The manifest will only include the available architectures
- **Example use case**: `rig-debian` is restricted to amd64 because certain dependencies are not available on arm64
- After adding or modifying arch comments, regenerate with `make stages` and `make generate-makefiles`
- **Important**: Even with restricted architectures, always use `image:latest` tag - the manifest handles the arch limitation automatically

## 7. Python Code Best Practices

### 7.1 Error Handling: Fail Fast

**DO NOT catch exceptions for file I/O operations in `generate_stages.py`**

- **Principle**: Let the script fail fast with clear error messages when something goes wrong
- **Rationale**:
    - If a Dockerfile doesn't exist or can't be read, it's a serious error that needs immediate attention
    - Catching and logging exceptions silently can hide problems and lead to incorrect generated files
    - Python's default exception messages are clear and include stack traces for debugging
- **Examples:**

  ```python
  # ✅ CORRECT - Let it fail with clear error
  def extract_base_image(self, dockerfile_path: Path) -> Optional[str]:
      with open(dockerfile_path, 'r', encoding='utf-8') as f:
          for line in f:
              # process line...
      return None

  # ❌ WRONG - Silently catches errors and continues
  def extract_base_image(self, dockerfile_path: Path) -> Optional[str]:
      try:
          with open(dockerfile_path, 'r', encoding='utf-8') as f:
              for line in f:
                  # process line...
      except (IOError, OSError) as e:
          print(f"Error reading {dockerfile_path}: {e}")
      return None
  ```

- **When to catch exceptions**: Only when you have a specific recovery strategy or when the error is expected and handleable
- **General rule**: If you can't do something meaningful to recover from an error, don't catch it

### 7.2 Formatting

- Use pylint and black for Python code formatting

## 8. Always Update CLAUDE.md

- **Always update** this CLAUDE.md file when making changes to Docker images or establishing new patterns
- Include any new best practices, patterns, or important considerations discovered during development
- Keep this file as a comprehensive guide for future maintenance and development
